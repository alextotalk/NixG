Интерфейсы
Интерфейсы в Go предоставляют способ указать
поведение объекта: если что-то может это сделать
 , то это можно использовать здесь .
 Мы уже видели пару простых примеров;
 пользовательские принтеры могут быть
 реализованы String методом, в то время как
  Fprintf могут генерировать вывод для
  чего угодно с помощью Write метода.
   Интерфейсы только с одним или двумя методами
   распространены в коде Go, и им обычно дается имя,
   производное от метода, например, io.Writer
   для чего-то, что реализует Write.

Тип может реализовывать несколько интерфейсов.
Например, коллекция может быть отсортирована
по рутинам в пакете , sort
если он реализует sort.Interface, в котором
содержится Len(), Less(i, j int) boolи Swap(i, j int),
и это также может иметь пользовательский форматировщик.
В этом надуманном примере Sequence удовлетворены оба.

type Sequence [] int
// Методы, необходимые для sort.Interface.
func (s Sequence) Len () int {
    return len (s)
}
func (s Sequence) Less (i, j int) bool {
    return s [i] <s [j]
}
func (s Sequence) Swap (i, j int) {
    s [i], s [j] = s [j], s [i]
}
// Копировать возвращает копию Последовательности.
func (s Sequence) Copy () Sequence {
    copy: = make (Sequence, 0, len (s))
    return append (copy, s ...)
}
// Метод для печати - сортирует элементы перед печатью.
func (s Sequence) String () string {
    s = s.Copy ()
    // Сделать копию; не перезаписывайте аргумент.
    sort.Sort (s)
    str: = "["
    for i, elem: = range s {
     // Цикл равен O (N²); исправим это в следующем примере.
        if i> 0 {
            str + = ""
        }
        str + = fmt.Sprint (elem)
    }
    return str + "]"
}
Конверсии
String Метод Sequence воссоздает работу ,
которая Sprint уже делает для слайса.
(Он также имеет сложность O (N²), что плохо.)
We can share the effort (and also speed it up)
if we convert the Sequence to a plain []int
before calling Sprint.

func (s Sequence) String () string {
    s = s.Copy ()
    sort.Sort (s)
    return fmt.Sprint ([] int (s))
}
Этот метод является еще одним примером техники
преобразования для Sprintf безопасного вызова из
Stringм метода. Поскольку два типа ( Sequenceи []int)
одинаковы, если мы игнорируем имя типа,
преобразование между ними разрешено.
Преобразование не создает новое значение, оно
просто временно действует так, как будто
существующее значение имеет новый тип.
(Существуют и другие разрешенные преобразования,
например, из целого числа в число с плавающей запятой,
которые создают новое значение.)

В программах Go используется идиома для
преобразования типа выражения для доступа к
другому набору методов. В качестве примера мы могли
бы использовать существующий тип,
sort.IntSlice чтобы свести весь пример к следующему:

type Sequence [] int

// Метод для печати - сортирует элементы перед печатью
func (s Sequence) String () string {
    s = s.Copy ()
    sort.IntSlice (s) .Sort ()
    return fmt.Sprint ([] int (s))
}

Теперь вместо Sequence
реализации нескольких интерфейсов
(сортировка и печать) мы используем
возможность преобразования элемента данных
в несколько типов ( Sequence, sort.IntSlice и []int),
каждый из которых выполняет некоторую часть работы.
На практике это более необычно, но может быть
эффективным.


    !!!!Преобразования интерфейсов и утверждения типов
Переключатели типа - это форма преобразования:
они принимают интерфейс и для каждого случая в
переключателе в некотором смысле преобразуют его в
тип этого случая. Вот упрощенная версия того, как
приведенный ниже код fmt.Printf превращает
значение в строку с помощью переключателя типа.
Если это уже строка, нам нужно фактическое значение
строки, хранимое интерфейсом, а если у него есть
String метод, нам нужен результат вызова метода.

type Stringer interface {
    String () string
}

var value interface {}
// Значение, предоставленное вызывающим.
switch str: = value. (type) {
case string:
    return str
case Stringer:
    return str.String ()
}

Первый случай находит конкретное значение; второй
преобразует интерфейс в другой интерфейс. Так
смешивать типы - это нормально.

Что, если нас интересует только один тип?
Если мы знаем, что значение содержит a,
string и мы просто хотим его извлечь?
Подойдет одноразовый переключатель типа,
но то же самое можно сделать и с утверждением типа .
Утверждение типа принимает значение интерфейса и
извлекает из него значение указанного явного типа.
Синтаксис заимствован из предложения, открывающего
type switch, но с явным типом, а не
type ключевым словом:

value. (typeName)
и результатом будет новое значение статического типа
typeName. Этот тип должен быть либо конкретным типом,
поддерживаемым интерфейсом, либо вторым типом
интерфейса, в который можно преобразовать значение.
Чтобы извлечь строку, которая, как мы знаем,
находится в значении, мы могли бы написать:

str: = value. (string)
Но если окажется, что значение не содержит строки,
программа выйдет из строя с ошибкой времени выполнения.
Чтобы избежать этого, используйте идиому
"comma, ok" , чтобы безопасно проверить,
является ли значение строкой:

str, ok: = значение. (строка)
if ok {
    fmt.Printf ("строковое значение:% q \ n", str)
} else {
    fmt.Printf ("значение не является строкой \ n")
}
Если утверждение типа не выполняется, strон все равно будет существовать и будет иметь тип string, но будет иметь нулевое значение, пустую строку.

В качестве иллюстрации возможности вот оператор if- else , эквивалентный переключателю типа, открывшему этот раздел.

если str, ok: = значение. (строка); ok {
    return str
} иначе, если str, ok: = значение. (Stringer); хорошо {
    return str.String ()
}
Общность
Если тип существует только для реализации интерфейса и никогда не будет экспортировать методы за пределами этого интерфейса, нет необходимости экспортировать сам тип. Экспорт только интерфейса проясняет, что значение не имеет интересного поведения, кроме того, что описано в интерфейсе. Это также позволяет избежать повторения документации для каждого экземпляра общего метода.

В таких случаях конструктор должен возвращать значение интерфейса, а не реализующий тип. Например, в хеш-библиотеках обе crc32.NewIEEEи adler32.New возвращают тип интерфейса hash.Hash32. Замена алгоритма CRC-32 на Adler-32 в программе Go требует только изменения вызова конструктора; на остальную часть кода изменение алгоритма не влияет.

Подобный подход позволяет cryptoотделить алгоритмы потокового шифрования в различных пакетах от блочных шифров, которые они объединяют в цепочку. BlockИнтерфейс в crypto/cipherпакете определяет поведение блочного шифра, который обеспечивает шифрование одного блока данных. Затем, по аналогии с bufioпакетом, пакеты шифрования, реализующие этот интерфейс, могут использоваться для создания потоковых шифров, представленных Streamинтерфейсом, без знания деталей блочного шифрования.

Эти crypto/cipherинтерфейсы выглядеть следующим образом :

тип Интерфейс блока {
    BlockSize () int
    Encrypt (dst, src [] byte)
    Decrypt (dst, src [] byte)
}

тип Интерфейс потока {
    XORKeyStream (dst, src [] byte)
}
Вот определение потока режима счетчика (CTR), который превращает блочный шифр в потоковый шифр; обратите внимание, что детали блочного шифра абстрагированы:

// NewCTR возвращает поток, который шифрует / дешифрует с использованием данного блока в
// режиме счетчика. Длина iv должна быть такой же, как размер блока.
func NewCTR (block Block, iv [] byte) Stream
NewCTRприменяется не только к одному конкретному алгоритму шифрования и источнику данных, но и к любой реализации Blockинтерфейса и к любому Stream. Поскольку они возвращают значения интерфейса, замена шифрования CTR другими режимами шифрования является локализованным изменением. Вызов конструктора необходимо отредактировать, но поскольку окружающий код должен обрабатывать результат только как a Stream, он не заметит разницы.

Интерфейсы и методы
Поскольку почти все может иметь присоединенные методы, почти все может удовлетворить интерфейс. Один наглядный пример находится в http пакете, который определяет Handlerинтерфейс. Любой реализуемый объект Handlerможет обслуживать HTTP-запросы.

type Handler interface {
    ServeHTTP (ResponseWriter, * Request)
}
ResponseWriterсам по себе является интерфейсом, который предоставляет доступ к методам, необходимым для возврата ответа клиенту. Эти методы включают стандартный Writeметод, поэтому его http.ResponseWriterможно использовать везде, где это io.Writer возможно. Request- это структура, содержащая проанализированное представление запроса от клиента.

Для краткости давайте проигнорируем POST и предположим, что HTTP-запросы всегда являются GET; это упрощение не влияет на способ настройки обработчиков. Вот тривиальная реализация обработчика для подсчета количества посещений страницы.

// Простой счетчик-сервер.
type Counter struct {
    n int
}

func (ctr * Counter) ServeHTTP (w http.ResponseWriter, req * http.Request) {
    ctr.n ++
    fmt.Fprintf (w, "counter =% d \ n", ctr.n)
}
(Продолжая нашу тему, обратите внимание, как Fprintfможно печатать на http.ResponseWriter.) На реальном сервере для доступа к нему ctr.nпотребуется защита от одновременного доступа. Смотрите syncи atomicпакеты предложений.

Для справки, вот как подключить такой сервер к узлу в дереве URL-адресов.

import "net / http"
...
ctr: = new (Counter)
http.Handle ("/ counter", ctr)
Но зачем создавать Counterструктуру? Все, что нужно - это целое число. (Получатель должен быть указателем, чтобы приращение было видно вызывающему.)

// Более простой счетчик-сервер.
type Counter int

func (ctr * Counter) ServeHTTP (w http.ResponseWriter, req * http.Request) {
    * ctr ++
    fmt.Fprintf (w, "counter =% d \ n", * ctr)
}
Что, если у вашей программы есть какое-то внутреннее состояние, которое нужно уведомить о посещении страницы? Привяжите канал к веб-странице.

// Канал, который отправляет уведомление при каждом посещении.
// (Возможно, вы хотите, чтобы канал был буферизован.)
Type Chan chan * http.Request

func (ch Chan) ServeHTTP (w http.ResponseWriter, req * http.Request) {
    ch <- req
    fmt.Fprint (w, "notification отправлено ")
}
Наконец, допустим, мы хотели представить /argsаргументы, используемые при вызове двоичного файла сервера. Легко написать функцию для вывода аргументов.

func ArgServer () {
    fmt.Println (os.Args)
}
Как превратить это в HTTP-сервер? Мы могли бы ArgServer создать метод какого-то типа, значение которого мы игнорируем, но есть более чистый способ. Поскольку мы можем определить метод для любого типа, кроме указателей и интерфейсов, мы можем написать метод для функции. httpПакет содержит этот код:

// Тип HandlerFunc - это адаптер, позволяющий использовать
// обычные функции в качестве обработчиков HTTP. Если f - функция
// с соответствующей подписью, HandlerFunc (f) - это
// объект-обработчик, который вызывает f.
type HandlerFunc func (ResponseWriter, * Request)

// ServeHTTP вызывает f (w, req).
func (f HandlerFunc) ServeHTTP (w ResponseWriter, req * Request) {
    f (w, req)
}
HandlerFunc- это тип с методом, ServeHTTPпоэтому значения этого типа могут обслуживать HTTP-запросы. Посмотрите на реализацию метода: получатель - это функция f, и вызов метода f. Это может показаться странным, но это не сильно отличается, скажем, от того, что получатель является каналом, а метод отправки по каналу.

Чтобы превратить его ArgServerв HTTP-сервер, мы сначала модифицируем его, чтобы он имел правильную подпись.

// Сервер аргументов.
func ArgServer (w http.ResponseWriter, req * http.Request) {
    fmt.Fprintln (w, os.Args)
}
ArgServerтеперь имеет ту же сигнатуру, что и HandlerFunc, поэтому его можно преобразовать в этот тип для доступа к его методам, так же, как мы преобразовали Sequenceв IntSlice для доступа IntSlice.Sort. Код для его настройки краток:

http.Handle ("/ аргументы", http.HandlerFunc (ArgServer))
Когда кто-то посещает страницу /args, обработчик, установленный на этой странице, имеет значение ArgServer и тип HandlerFunc. HTTP-сервер вызовет метод ServeHTTP этого типа ArgServerв качестве получателя, который, в свою очередь, вызовет ArgServer(через вызов f(w, req) внутри HandlerFunc.ServeHTTP). Затем будут отображены аргументы.

В этом разделе мы создали HTTP-сервер из структуры, целого числа, канала и функции, все потому, что интерфейсы - это просто наборы методов, которые могут быть определены (почти) для любого типа.

Пустой идентификатор
Мы уже пару раз упоминали пустой идентификатор в контексте for rangeциклов и карт . Пустой идентификатор может быть назначен или объявлен с любым значением любого типа, при этом значение отбрасывается безвредно. Это немного похоже на запись в /dev/nullфайл Unix : оно представляет собой значение только для записи, которое будет использоваться в качестве заполнителя, когда переменная необходима, но фактическое значение не имеет значения. У него есть применение, выходящее за рамки тех, что мы уже видели.

Пустой идентификатор при множественном присвоении
Использование пустого идентификатора в for rangeцикле - это частный случай общей ситуации: множественное присвоение.

Если для присвоения требуется несколько значений в левой части, но одно из значений не будет использоваться программой, пустой идентификатор в левой части назначения позволяет избежать необходимости создания фиктивной переменной и дает понять, что значение следует отбросить. Например, при вызове функции, которая возвращает значение и ошибку, но важна только ошибка, используйте пустой идентификатор, чтобы отбросить нерелевантное значение.

если _, ошибка: = os.Stat (путь); os.IsNotExist (err) {
	fmt.Printf ("% s не существует \ n", путь)
}
Иногда вы увидите код, который отбрасывает значение ошибки, чтобы игнорировать ошибку; это ужасная практика. Всегда проверяйте возврат ошибок; они предоставляются по какой-то причине.

// Плохой! Этот код выйдет из строя, если путь не существует.
fi, _: = os.Stat (путь)
if fi.IsDir () {
    fmt.Printf ("% s - это каталог \ n", путь)
}
 ------ понимать, что такое указатели
 использовать специальный тип данных — указатель:

 func zero(xPtr *int) {
     *xPtr = 0
 }
 func main() {
     x := 5
     zero(&x)
     fmt.Println(x) // x is 0
 }
 Указатели указывают (прошу прощения за тавтологию)
 на участок в памяти, где хранится значение.
 Используя указатель (*int) в функции zero, мы
 можем изменить значение оригинальной переменной.


 ---- уметь применять указатели

 https://www.geeksforgeeks.org/pointers-in-golang/

---- - знать, для чего нужны операторы new, * и &
 Объявление и инициализация указателей
 Прежде чем мы начнем, есть два важных оператора,
 которые мы будем использовать в указателях, т.е.

 * Оператор также называется оператором разыменования,
 который используется для объявления
 переменной-указателя и доступа к значению, хранящемуся в адресе.

 Оператор &, называемый оператором адреса, используется
 для возврата адреса переменной или для доступа к
 адресу переменной к указателю.

 Объявление указателя :

 var pointer_name * Data_Type
 Пример: ниже указан указатель типа string, который
 может хранить только адреса памяти строковых
 переменных.

 var s * строка
 Инициализация указателя: для этого вам необходимо
 инициализировать указатель адресом памяти другой
 переменной, используя оператор адреса, как показано
 в следующем примере:

 // обычное объявление переменной
 var a = 45

 // Инициализация указателя s с помощью
 // адрес памяти переменной a
 var s * int = & a


!!!Разыменование указателя
Как мы знаем, этот оператор * также называется
оператором разыменования. Он не только используется
для объявления переменной-указателя, но также
используется для доступа к значению, хранящемуся в
переменной, на которую указывает указатель, что обычно
называется косвенным обращением или разыменованием .
Оператор * также называется значением по адресу .
Давайте рассмотрим пример, чтобы лучше понять эту
концепцию:

Пример:

// Golang program to illustrate the
// concept of dereferencing a pointer
package main

import "fmt"

func main() {

    // using var keyword
    // we are not defining
    // any type with variable
    var y = 458

    // taking a pointer variable using
    // var keyword without specifying
    // the type
    var p = &y

    fmt.Println("Value stored in y = ", y)
    fmt.Println("Address of y = ", &y)
    fmt.Println("Value stored in pointer variable p = ", p)

    // this is dereferencing a pointer
    // using * operator before a pointer
    // variable to access the value stored
    // at the variable at which it is pointing
    fmt.Println("Value stored in y(*p) = ", *p)

}
Выход:

Значение хранится в y = 458
Адрес y = 0x414020
Значение, хранящееся в переменной-указателе p = 0x414020
Значение хранится в y (* p) = 458
Вы также можете изменить значение указателя или в ячейке
памяти вместо того, чтобы присваивать новое значение
переменной.

Пример:

// Golang program to illustrate the
// above mentioned concept
package main

import "fmt"

func main() {

    // using var keyword
    // we are not defining
    // any type with variable
    var y = 458

    // taking a pointer variable using
    // var keyword without specifying
    // the type
    var p = &y

    fmt.Println("Value stored in y before changing = ", y)
    fmt.Println("Address of y = ", &y)
    fmt.Println("Value stored in pointer variable p = ", p)

    // this is dereferencing a pointer
    // using * operator before a pointer
    // variable to access the value stored
    // at the variable at which it is pointing
    fmt.Println("Value stored in y(*p) Before Changing = ", *p)

    // changing the value of y by assigning
    // the new value to the pointer
    *p = 500

     fmt.Println("Value stored in y(*p) after Changing = ",y)

}
Выход:

Значение, сохраненное в y перед изменением = 458
Адрес y = 0x414020
Значение, хранящееся в переменной-указателе p = 0x414020
Значение, сохраненное в y (* p) до изменения = 458
Значение, сохраненное в y (* p) после изменения = 500

Оператор new
Другой способ получить указатель — использовать
встроенную функцию new:

func one(xPtr *int) {
    *xPtr = 1
}
func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr) // x is 1
}
Функция new принимает аргументом тип, выделяет
для него память и возвращает указатель на эту память.

В некоторых языках программирования есть существенная
разница между использованием new и &, и в них нужно
удалять всё, что было создано с помощью new. Go не
такой - Go хороший. Go — язык с автоматической сборкой
мусора. Это означает, что область памяти очищается
автоматически, когда на неё не остаётся ссылок.

Указатели редко используются в Go для встроенных типов
(они чрезвычайно полезны при работе со структурами).

---- - знать, в чем разница между указателем и
обычной переменной

 Указатели в языке программирования Go или Golang -
 это переменная, которая используется для хранения
 адреса в памяти другой переменной. Указатели в Golang
 также называют специальными переменными. Эти переменные
 используются для хранения некоторых данных по
 определенному адресу памяти в системе. Адрес памяти
 всегда находится в шестнадцатеричном формате
 (начиная с 0x, например, 0xFFAAF и т. Д.).

 Зачем нужны указатели?
 Чтобы понять эту потребность, во-первых, мы должны
 понять концепцию переменных. Переменные - это имена,
 присвоенные той области памяти, где хранятся фактические
 данные. Чтобы получить доступ к сохраненным данным,
 нам нужен адрес этой конкретной области памяти.
 Запоминание всех адресов памяти (шестнадцатеричный формат)
 вручную - это накладные расходы, поэтому мы используем
 переменные для хранения данных, а к переменным можно
 получить доступ, просто используя их имя.
 Golang также позволяет сохранять шестнадцатеричное число
 в переменную, используя буквальное выражение, т.е. число,
 начинающееся с 0x, является шестнадцатеричным числом.

 Пример: В приведенной ниже программе мы сохраняем
 шестнадцатеричное число в переменной. Но вы можете видеть,
 что тип значений - int и сохраняется как десятичное, или
 вы можете сказать, что десятичное значение типа int
 хранится. Но основной момент для объяснения этого
 примера заключается в том, что мы сохраняем шестнадцатеричное
 значение (считайте его адресом памяти), но это не указатель,
 поскольку он не указывает на какое-либо другое место в
 памяти другой переменной. Это просто переменная, определяемая
 пользователем. Таким образом, возникает необходимость в
 указателях.


 атической сборкой мусора. Это означает, что область памяти очищается автоматически, когда на неё не остаётся ссылок.

 Указатели редко используются в Go для встроенных типов, но они будут часто фигурировать в следующей главе (они чрезвычайно полезны при работе со структурами).

 Задачи???
 ????Как получить адрес переменной?

Use & x:= 4
&x ==0xc000134018

??? Как присвоить значение указателю?

 *x=5
 Now x==5

 ????Как создать новый указатель?

var pointer_name * Data_Type
Пример: ниже указан указатель типа string,
который может хранить только адреса памяти строковых переменных.
var s * строка

func one(xPtr *int) {
    *xPtr = 1
}
func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr) // x is 1
}

????? Какое будет значение у переменной x после выполнения программы:

 func square(x *float64) {
     *x = *x * *x
 }
 func main() {
     x := 1.5
     square(&x)
 }

2.25

??? Напишите программу, которая меняет местами
два числа (x := 1; y := 2; swap(&x, &y)
должно дать x=2 и y=1).

func swap(x,y *int) {
	tmp:=*x
	*x=*y
	*y=tmp
}
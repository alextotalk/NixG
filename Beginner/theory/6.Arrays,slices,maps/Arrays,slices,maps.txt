 http://golang-book.ru/chapter-06-arrays-slices-maps.html

    - знать, в чем разница между массивом и слайсом

var x [4]float64
 Массив -— это нумерованная последовательность элементов
 одного типа с фиксированной длиной.

var x []float64
 Срез -- это часть массива. Как и массивы, срезы индексируются и имеют длину.
 В отличии от массивов их длину можно изменить.
 Единственное отличие объявления среза от объявления массива —
 отсутствие указания длины в квадратных скобках.
 В нашем случае x будет иметь длину 0.
 x := make([]float64, 5)
 Этот код создаст срез, который связан с массивом типа float64, длиной 5.
 Срезы всегда связаны с каким-нибудь массивом.
 Они не могут стать больше чем массив, а вот меньше — пожалуйста.
  Функция make принимает и третий параметр:
  x := make([]float64, 5, 10)
  10 — это длина массива, на который указывает срез:
  В Go есть две встроенные функции для срезов: append и copy.
  Вот пример работы функции append:
 func main() {
        slice1 := []int{1,2,3}
        slice2 := append(slice1, 4, 5)
        fmt.Println(slice1, slice2)
    }
    После выполнения программы slice1 будет содержать [1,2,3],
    а slice2 — [1,2,3,4,5]. append создает новый срез из уже существующего
    (первый аргумент) и добавляет к нему все следующие аргументы.

    Пример работы copy:

    func main() {
        slice1 := []int{1,2,3}
        slice2 := make([]int, 2)
        copy(slice2, slice1)
        fmt.Println(slice1, slice2)
    }
    После выполнения этой программы slice1 будет содержать
    [1,2,3], а slice2 — [1,2]. Содержимое slice1 копируется в slice2,
     но поскольку в slice2 есть место только для двух элементов,
    то только два первых элемента slice1 будут скопированы.

Карта (также известна как ассоциативный массив или словарь) —
это неупорядоченная коллекция пар вида ключ-значение.
var x map[string]int
var x map[string]int
x["key"] = 10
fmt.Println(x)f

Запустим следующую программу:

var x map[string]int
x["key"] = 10
fmt.Println(x)
Вы должны увидеть ошибку, похожую на эту:
Проблема нашей программы в том, что карта должна быть
инициализирована перед тем, как будет использована.
Надо написать так:

x := make(map[string]int)
x["key"] = 10
fmt.Println(x["key"])
Мы также можем создать карты с ключом типа int:

x := make(map[int]int)
x[1] = 10
fmt.Println(x[1])
Это выглядит очень похоже на массив, но существует
несколько различий. Во-первых, длина карты (которую
мы можем найти так: len(x)) может измениться, когда
мы добавим в нее новый элемент. В самом начале при
создании длина 0, после x[1] = 10 она станет равна 1.
Во-вторых, карта не является последовательностью.
В нашем примере у нас есть элемент x[1], в случае
массива должен быть и первый элемент x[0], но в картах
это не так.

Также мы можем удалить элементы из карты используя
встроенную функцию delete:

delete(x, 1)

Давайте посмотрим на пример программы, использующей карты:

func main() {
    elements := make(map[string]string)
    elements["H"] = "Hydrogen"
    elements["He"] = "Helium"
    elements["Li"] = "Lithium"
    elements["Be"] = "Beryllium"
    elements["B"] = "Boron"
    elements["C"] = "Carbon"
    elements["N"] = "Nitrogen"
    elements["O"] = "Oxygen"
    elements["F"] = "Fluorine"
    elements["Ne"] = "Neon"

    fmt.Println(elements["Li"])
}
В данном примере elements - это карта,
которая представляет 10 первых химических элементов,
индексируемых символами. Это очень частый способ
использования карт — в качестве словаря или таблицы.
Предположим, мы пытаемся обратиться к несуществующему
элементу:

fmt.Println(elements["Un"])
Если вы выполните это, то ничего не увидите.
Технически карта вернет нулевое значение хранящегося
типа (для строк это пустая строка). Несмотря на то,
что мы можем проверить нулевое значение с помощью
условия (elements["Un"] == ""), в Go есть лучший способ
сделать это:

name, ok := elements["Un"]
fmt.Println(name, ok)
Доступ к элементу карты может вернуть два значения
вместо одного. Первое значение это результат запроса,
второе говорит, был ли запрос успешен. В Go часто
встречается такой код:

if name, ok := elements["Un"]; ok {
    fmt.Println(name, ok)
}
Сперва мы пробуем получить значение из карты, а
затем, если это удалось, мы выполняем код внутри блока.

Объявления карт можно записывать сокращенно - так же, как массивы:

elements := map[string]string{
    "H": "Hydrogen",
    "He": "Helium",
    "Li": "Lithium",
    "Be": "Beryllium",
    "B": "Boron",
    "C": "Carbon",
    "N": "Nitrogen",
    "O": "Oxygen",
    "F": "Fluorine",
    "Ne": "Neon",
}
 - уметь пользоваться массивами, слайсами и картами

?? Как обратиться к четвертому элементу массива или среза?
  arr[3]

??Чему равна длина среза, созданного таким способом:
make([]int, 3, 9)?
equal =3

??Дан массив:
x := [6]string{"a","b","c","d","e","f"}
что вернет вам x[2:5]?
[c,d,e]

??Напишите программу, которая находит самый наименьший элемент в этом списке:

 els := []int{
 		48, 96, 86, 68,
 		57, 82, 63, 70,
 		37, 34, 83, 27,
 		19, 97, 9, 17,
 	}

 	minEl := els[0]
 	for _, vol := range els {
 		if minEl > vol {
 			minEl = vol
 		}
 	}
 	fmt.Println(minEl)


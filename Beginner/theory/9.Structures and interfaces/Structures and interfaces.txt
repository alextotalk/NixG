----- общее понимание структур
package main

import ("fmt"; "math")

func distance(x1, y1, x2, y2 float64) float64 {
    a := x2 - x1
    b := y2 - y1
    return math.Sqrt(a*a + b*b)
}
func rectangleArea(x1, y1, x2, y2 float64) float64 {
    l := distance(x1, y1, x1, y2)
    w := distance(x1, y1, x2, y1)
    return l * w
}
func circleArea(x, y, r float64) float64 {
    return math.Pi * r*r
}
func main() {
    var rx1, ry1 float64 = 0, 0
    var rx2, ry2 float64 = 10, 10
    var cx, cy, cr float64 = 0, 0, 5

    fmt.Println(rectangleArea(rx1, ry1, rx2, ry2))
    fmt.Println(circleArea(cx, cy, cr))
}
Отслеживание всех переменных мешает нам понять,
что делает программа, и наверняка приведет к ошибкам.

Структуры
С помощью структур эту программу можно сделать
гораздо лучше. Структура — это тип, содержащий
именованные поля. Например, мы можем представить
круг таким образом:

type Circle struct {
    x float64
    y float64
    r float64
}
Ключевое слово type вводит новый тип. За ним следует
имя нового типа (Circle) и ключевое слово struct,
которое говорит, что мы определяем структуру и
список полей внутри фигурных скобок. Каждое поле
имеет имя и тип. Как и с функциями, мы можем
объединять поля одного типа:

type Circle struct {
    x, y, r float64
}

-----инициализация структур

Инициализация
Мы можем создать экземпляр нового типа
Circle несколькими способами:

var c Circle
Подобно другим типами данных, будет
создана локальная переменная типа Circle,
чьи поля по умолчанию будут равны нулю
(0 для int, 0.0 для float, "" для string, nil
для указателей, …). Также, для создания экземпляра
можно использовать функцию new.

c := new(Circle)
Это выделит память для всех полей, присвоит каждому
из них нулевое значение и вернет указатель (*Circle).
Часто, при создании структуры мы хотим присвоить полям
структуры какие-нибудь значения. Существует два способа
сделать это. Первый способ:

c := Circle{x: 0, y: 0, r: 5}
Второй способ — мы можем опустить имена полей, если мы
знаем порядок в котором они определены:

c := Circle{0, 0, 5}


------ поля структур

Получить доступ к полям можно с помощью оператора . (точка):

fmt.Println(c.x, c.y, c.r)
c.x = 10
c.y = 5
Давайте изменим функцию circleArea так, чтобы она
использовала структуру Circle:

func circleArea(c Circle) float64 {
    return math.Pi * c.r*c.r
}
В функции main у нас будет:

c := Circle{0, 0, 5}
fmt.Println(circleArea(c))
Очень важно помнить о том, что аргументы в Go всегда
копируются. Если мы попытаемся изменить любое поле в
функции circleArea, оригинальная переменная не изменится.
Именно поэтому мы будем писать функции так:

func circleArea(c *Circle) float64 {
    return math.Pi * c.r*c.r
}
И изменим main:

c := Circle{0, 0, 5}
fmt.Println(circleArea(&c))


- -----методы структур

Методы
Несмотря на то, что программа стала лучше, мы все еще
можем значительно её улучшить, используя метод —
функцию особого типа:

func (c *Circle) area() float64 {
    return math.Pi * c.r*c.r
}
Между ключевым словом func и именем функции мы добавили
«получателя». Получатель похож на параметр — у него есть
имя и тип, но объявление функции таким способом позволяет
нам вызывать функцию с помощью оператора .:

fmt.Println(c.area())
Это гораздо проще прочесть, нам не нужно использовать оператор & (Go автоматически предоставляет доступ к указателю на Circle для этого метода), и поскольку эта функция может быть использована только для Circle мы можем назвать её просто area.

Давайте сделаем то же самое с прямоугольником:

type Rectangle struct {
    x1, y1, x2, y2 float64
}
func (r *Rectangle) area() float64 {
    l := distance(r.x1, r.y1, r.x1, r.y2)
    w := distance(r.x1, r.y1, r.x2, r.y1)
    return l * w
}
В main будет написано:

r := Rectangle{0, 0, 10, 10}
fmt.Println(r.area())


----- встраиваемые типы
- понимание интерфейсов и умение пользоваться интерфейсами